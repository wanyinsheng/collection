### Java内存模型（JMM）

#### 1. Java内存模型概述
Java内存模型（JMM）是一种规范，用来屏蔽各种硬件和操作系统的内存访问差异，以实现Java程序在所有平台上都能达到一致的内存访问效果。JMM定义了线程如何以及何时可以看到其他线程修改过的共享变量的值，以及如何同步访问共享变量。

#### 2. JMM主要组成
##### 2.1 主内存（Main Memory）
主内存是所有线程共享的内存区域，其中存储了Java程序中的实例字段，静态字段和构成数组对象的元素。主内存相当于计算机的物理内存。

##### 2.2 工作内存（Working Memory）
每个线程都有自己的工作内存，工作内存是每个线程的私有数据区域。它包含了线程用到的变量的主内存副本。线程对变量的所有操作（读取，赋值等）都必须在工作内存中进行，不能直接读写主内存中的数据。

#### 3. JMM的内存交互操作
##### 3.1 锁定（Lock）
线程在访问某个变量前，需要先获得锁，确保其他线程不能同时修改该变量。

##### 3.2 解锁（Unlock）
线程在访问某个变量后，需要释放锁，使得其他线程能够访问该变量。

##### 3.3 读取（Read）
线程从主内存中读取变量，以便在工作内存中创建该变量的副本。

##### 3.4 加载（Load）
线程在工作内存中对读取的变量进行加载，之后才能执行后续操作。

##### 3.5 使用（Use）
线程使用工作内存中的变量副本进行操作。

##### 3.6 赋值（Assign）
线程将变更后的变量值赋值回工作内存的变量副本。

##### 3.7 存储（Store）
线程将工作内存中的变量副本的值传递到主内存中，以便其他线程可以读取。

##### 3.8 写入（Write）
线程在主内存中对变量进行写入，完成更新。

#### 4. JMM的同步规定
Java内存模型通过volatile关键字、synchronized关键字、final关键字、锁以及并发包中的原子变量等机制来保证内存的可见性、原子性和有序性。

##### 4.1 可见性
确保一个线程修改了共享变量的值后，其他线程能够立即得知这个修改。

##### 4.2 原子性
保证一个操作或多个操作要么全部执行且不会被中断，要么就都不执行。

##### 4.3 有序性
确保程序执行的顺序按照代码的先后顺序执行。

#### 5. 结论
Java内存模型是理解并发编程中共享变量如何以及何时被线程访问的关键。JMM定义了线程和主内存之间的抽象关系，并通过一系列操作和规则来保证线程间的可见性、原子性和有序性。理解JMM对于编写可靠和高效的并发程序至关重要。


### synchronized 和 volatile 的区别

#### 1. synchronized
`synchronized`关键字是Java中的同步机制，它可以用来修饰方法或代码块。

##### 1.1 作用
- **互斥性**：保证同一时刻只有一个线程可以执行synchronized修饰的方法或代码块。
- **可见性**：当一个线程退出synchronized块时，它对变量所做的所有修改都将被刷新到主内存中，当其他线程进入synchronized块时，它们将看到由前一个线程所做的修改。

##### 1.2 特点
- **锁的概念**：synchronized关键字涉及到锁的概念，包括对象锁（监视器锁）和类锁。
- **重量级**：synchronized是重量级操作，因为它涉及到操作系统的同步机制。

#### 2. volatile
`volatile`关键字是一种轻量级的同步机制，主要用于修饰变量。

##### 2.1 作用
- **可见性**：保证了不同线程对volatile修饰的变量进行读写时的可见性，即一个线程修改了某个volatile变量的值，这新值对其他线程来说是立即可见的。
- **禁止指令重排序**：volatile变量的写-读可以实现一定的“happens-before”关系，从而避免指令重排序。

##### 2.2 特点
- **轻量级**：不会造成线程的阻塞。
- **无互斥性**：volatile不涉及同步锁，不保证操作的原子性。

#### 3. 主要区别
##### 3.1 互斥性与原子性
- **synchronized**：保证了操作的原子性和互斥性。
- **volatile**：不保证原子性，只保证读写操作的可见性和有序性。

##### 3.2 性能开销
- **synchronized**：由于涉及到系统级的锁定，其性能开销比volatile大。
- **volatile**：作为一种轻量级的同步策略，其性能开销相对较小。

##### 3.3 应用场景
- **synchronized**：适用于多个线程需要访问同步代码块并且涉及到状态变更的场景。
- **volatile**：适用于变量的状态标记，或者保证内存可见性的场景，且操作不依赖于当前值。

#### 4. 结论
`synchronized`和`volatile`关键字都可以解决多线程中的可见性问题，但是`synchronized`还可以保证原子性和互斥性。`volatile`适用于简单的同步场景，而`synchronized`适用于更复杂的线程同步需求。正确选择使用`synchronized`或`volatile`，取决于具体的应用场景和需求。

### CyclicBarrier

#### 1. 概念
`CyclicBarrier` 是一个同步辅助类，用于协调多个线程之间的同步。它允许一组线程相互等待，直到所有线程都到达一个公共屏障点（Barrier Point），然后这些线程才能继续执行。

#### 2. 工作机制
##### 2.1 初始化
- 创建 `CyclicBarrier` 对象时，你需要指定一个整数，它表示屏障拦截的线程数量。

##### 2.2 使用
- 当线程调用 `await()` 方法时，线程会被阻塞。
- 等到所有线程都调用了 `await()` 方法，即线程数量达到了你初始化 `CyclicBarrier` 时指定的数量，所有被拦截的线程才会继续执行。

##### 2.3 循环使用
- `CyclicBarrier` 是可循环利用的，即当所有等待线程都被释放后，`CyclicBarrier` 可以为下一组线程提供相同的屏障。

#### 3. 功能和用途
##### 3.1 同步点
- `CyclicBarrier` 可以用作多线程程序中的一个同步点，所有的线程必须等到彼此都达到这个点后才能继续执行。

##### 3.2 并行计算
- 在分布式并行计算中，可以使用 `CyclicBarrier` 来同步分割的计算任务，当所有子任务都完成时，才进行下一步的操作。

##### 3.3 复杂流程控制
- 在需要多个线程相互等待至某个状态后才能执行某项操作的场景中，`CyclicBarrier` 是一个合适的选择。

#### 4. 特性
##### 4.1 可选的屏障动作
- 在所有线程到达屏障时，可以执行一个可选的屏障动作，这是一个实现了 `Runnable` 接口的命令。

##### 4.2 异常处理
- 如果在等待过程中，线程被中断，`await()` 方法会抛出 `InterruptedException`。
- 如果等待过程中，`CyclicBarrier` 被重置，或者在调用 `await()` 时屏障被破坏，或者超时，它会抛出 `BrokenBarrierException` 或者 `TimeoutException`。

#### 5. 与其他同步辅助类的比较
`CyclicBarrier` 与 `CountDownLatch` 相似，但有以下主要区别：
- `CountDownLatch` 是一次性的，计数器到达零后不能被重置，而 `CyclicBarrier` 可以重置后再次使用。
- `CyclicBarrier` 允许执行一个屏障动作，而 `CountDownLatch` 不提供这样的功能。

#### 6. 结论
`CyclicBarrier` 是一个多线程同步的实用工具，它允许一组线程互相等待，直到所有线程都到达一个公共的屏障点。它特别适用于那些多步骤的并行任务，可以在完成一组相关任务后同步线程的进度，然后再继续执行后续的任务。















